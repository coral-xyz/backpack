/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 * > npx openapi-typescript https://api.blowfish.xyz/openapi/v20230605.yaml --output Blowfish_v20230605.ts
 */

export interface paths {
  "/ethereum/v0/mainnet/historical/transaction": {
    /**
     * EVM
     * @description Simulates historical transaction to get the actual state changes it produced.
     * ### Supported networks
     * | Network | Base URL |
     * | --- | --- |
     * | Ethereum Mainnet | https://api.blowfish.xyz/ethereum/v0/mainnet/historical/transaction |
     * | Goerli Testnet | https://api.blowfish.xyz/ethereum/v0/goerli/historical/transaction |
     * | Polygon Mainnet | https://api.blowfish.xyz/polygon/v0/mainnet/historical/transaction |
     * | Polygon Mumbai Testnet  | https://api.blowfish.xyz/polygon/v0/mumbai/historical/transaction |
     * | BNB Chain Mainnet | https://api.blowfish.xyz/bnb/v0/mainnet/historical/transaction |
     * | Arbitrum One | https://api.blowfish.xyz/arbitrum/v0/one/historical/transaction |
     * | Optimism Goerli Testnet | https://api.blowfish.xyz/optimism/v0/goerli/historical/transaction |
     * | Optimism Mainnet | https://api.blowfish.xyz/optimism/v0/mainnet/historical/transaction |
     * | Base Mainnet | https://api.blowfish.xyz/base/v0/mainnet/historical/transaction |
     * | Base Goerli Testnet | https://api.blowfish.xyz/base/v0/goerli/historical/transaction |
     */
    post: operations["historical-transaction-evm"];
  };
  "/ethereum/v0/mainnet/scan/transactions": {
    /**
     * EVM
     * @description Scan a list of EVM transactions in order to receive recommended actions, tailored warnings and human-readable simulation results explaining what the transactions will do.
     * ### Supported networks
     * | Network | Base URL |
     * | --- | --- |
     * | Ethereum Mainnet | https://api.blowfish.xyz/ethereum/v0/mainnet/scan/transactions |
     * | Goerli Testnet | https://api.blowfish.xyz/ethereum/v0/goerli/scan/transactions |
     * | Polygon Mainnet | https://api.blowfish.xyz/polygon/v0/mainnet/scan/transactions |
     * | Polygon Mumbai Testnet  | https://api.blowfish.xyz/polygon/v0/mumbai/scan/transactions |
     * | BNB Chain Mainnet | https://api.blowfish.xyz/bnb/v0/mainnet/scan/transactions |
     * | Arbitrum One | https://api.blowfish.xyz/arbitrum/v0/one/scan/transactions |
     * | Optimism Goerli Testnet | https://api.blowfish.xyz/optimism/v0/goerli/scan/transactions |
     * | Base Mainnet | https://api.blowfish.xyz/base/v0/mainnet/scan/transactions |
     * | Base Goerli Testnet | https://api.blowfish.xyz/base/v0/goerli/scan/transactions |
     * Note:  All EVM scan endpoints are equivalent when it comes to functionality as well as request and response formats.
     */
    post: operations["scan-transactions-evm"];
  };
  "/ethereum/v0/mainnet/scan/transaction": {
    /**
     * EVM
     * @deprecated
     * @description [DEPRECATED] Use Scan transactions endpoint instead.
     * https://docs.blowfish.xyz/reference/scan-transactions-evm
     * [Sunset] 31.12.2023
     * Scan an EVM transaction in order to receive recommended actions, tailored warnings and human-readable simulation results explaining what the transaction will do.
     * ### Supported networks
     * | Network | Base URL |
     * | --- | --- |
     * | Ethereum Mainnet | https://api.blowfish.xyz/ethereum/v0/mainnet/scan/transaction |
     * | Goerli Testnet | https://api.blowfish.xyz/ethereum/v0/goerli/scan/transaction |
     * | Polygon Mainnet | https://api.blowfish.xyz/polygon/v0/mainnet/scan/transaction |
     * | Polygon Mumbai Testnet  | https://api.blowfish.xyz/polygon/v0/mumbai/scan/transaction |
     * | BNB Chain Mainnet | https://api.blowfish.xyz/bnb/v0/mainnet/scan/transaction |
     * | Arbitrum One | https://api.blowfish.xyz/arbitrum/v0/one/scan/transaction |
     * | Optimism Goerli Testnet | https://api.blowfish.xyz/optimism/v0/goerli/scan/transaction |
     * | Optimism Mainnet | https://api.blowfish.xyz/optimism/v0/mainnet/scan/transaction |
     * | Base Mainnet | https://api.blowfish.xyz/base/v0/mainnet/scan/transaction |
     * | Base Goerli Testnet | https://api.blowfish.xyz/base/v0/goerli/scan/transaction |
     * Note:  All EVM scan endpoints are equivalent when it comes to functionality as well as request and response formats.
     */
    post: operations["scan-transaction-evm"];
  };
  "/ethereum/v0/mainnet/scan/message": {
    /**
     * EVM
     * @description Scan an EVM message in order to receive recommended actions, tailored warnings and human-readable simulation results explaining what signing the message will do.
     * ### Supported networks
     * | Network | Base URL |
     * | --- | --- |
     * | Ethereum Mainnet | https://api.blowfish.xyz/ethereum/v0/mainnet/scan/message |
     * | Goerli Testnet | https://api.blowfish.xyz/ethereum/v0/goerli/scan/message |
     * | Polygon Mainnet | https://api.blowfish.xyz/polygon/v0/mainnet/scan/message |
     * | Polygon Mumbai Testnet  | https://api.blowfish.xyz/polygon/v0/mumbai/scan/message |
     * | BNB Chain Mainnet | https://api.blowfish.xyz/bnb/v0/mainnet/scan/message |
     * | Arbitrum One | https://api.blowfish.xyz/arbitrum/v0/one/scan/message |
     * | Optimism Goerli Testnet | https://api.blowfish.xyz/optimism/v0/goerli/scan/message |
     * | Optimism Mainnet | https://api.blowfish.xyz/optimism/v0/mainnet/scan/message |
     * | Base Mainnet | https://api.blowfish.xyz/base/v0/mainnet/scan/message |
     * | Base Goerli Testnet | https://api.blowfish.xyz/base/v0/goerli/scan/message |
     * Note:  All EVM scan endpoints are equivalent when it comes to functionality as well as request and response formats.
     */
    post: operations["scan-message-evm"];
  };
  "/solana/v0/mainnet/scan/transactions": {
    /**
     * Solana
     * @description Scan Solana transactions in order to receive recommended actions, tailored warnings and human-readable simulation results explaining what the transaction will do. The API will return a list of warnings and a list of human-readable simulation results.
     * ### Supported networks
     * | Network | Base URL |
     * | --- | --- |
     * | Mainnet | https://api.blowfish.xyz/solana/v0/mainnet/scan/transactions |
     * | Testnet | https://api.blowfish.xyz/solana/v0/testnet/scan/transactions |
     * | Devnet | https://api.blowfish.xyz/solana/v0/devnet/scan/transactions |
     */
    post: operations["scan-transactions-solana"];
  };
  "/v0/domains/blocklist": {
    /**
     * Blocklist
     * @description Generate a downloadable snapshot with all blocked domains in order to check domains a user visits against a local blocklist, preserving their browsing privacy.
     *
     * ### Integration
     * This API enables to verify domain safety while maintaining the end user's privacy. To integrate this API into your app, you should follow the steps below:
     *
     * 1. Regularly update the blocklist metadata from the `/v0/domains/blocklist` endpoint.
     *   - In browser extensions, set up a timer to update the blocklist every 2-5 minutes.
     *   - In mobile apps, update the blocklist each time the user opens the app and every 2-5 minutes while the user is using the app.
     *   - New values of `recentlyAdded` and `recentlyRemoved` should be stored after each update, regardless of whether the bloom filter has changed.
     * 2. During each update, check if the app has previously downloaded a bloom filter with the hash `bloomFilter.hash`. If not, download it from `bloomFilter.url`.
     *   - Since the bloom filter can be up to 1MB in size, make sure you never re-download the same bloom filter. Identical bloom filters always have the same URL and the same hash.
     *   - Store the blocklist metadata (`recentlyAdded`, `recentlyRemoved`), bloom filter hash, and downloaded bloom filter.
     *   - Chrome extensions can use localStorage. The endpoint is designed with a 5MB limit on localStorage in mind.
     *   - The bloom filter is changed once a day, so users will never use more than 1 MB of traffic per day if the download and local caching logic is implemented correctly.
     * 3. When the user visits a domain, check if the domain is present on the bloom filter or the `recentlyAdded` list from the blocklist metadata and isn't present on the `recentlyRemoved` list. If this is the case, block the user from visiting the website.
     *
     * Browser extensions and React Native apps can use the Javascript package [@blowfish/blocklist](https://www.npmjs.com/package/@blowfishxyz/blocklist) to implement the outlined logic. For example:
     *
     * ```js
     * // Regular updates
     * import { fetchDomainBlocklist, fetchDomainBlocklistBloomFilter } from '@blowfishxyz/blocklist';
     *
     * const blocklist = await fetchDomainBlocklist(apiConfig);
     * [...] // save blocklist.recentlyAdded and blocklist.recentlyRemoved to a local database
     * const storedHash = [...]; // fetch it from your storage
     * if (storedHash != blocklist.bloomFilter.hash) {
     *     const bloomFilter = await fetchDomainBlocklistBloomFilter(blocklist.bloomFilter.url);
     *     [...] // save bloomFilter to a local database
     *     [...] // save bloomFilter.hash or blocklist.bloomFilter.hash to a local database
     * }
     *
     * // Lookups
     * import { scanDomain, Action } from '@blowfishxyz/blocklist';
     *
     * const recentlyAdded = [...]; // get from storage
     * const recentlyRemoved = [...]; // get from storage
     * const bloomFilter = [...]; // get from storage
     *
     * const action = scanDomain(
     *     bloomFilter,
     *     recentlyAdded,
     *     recentlyRemoved,
     *     "https://example.com/"
     * );
     *
     * if (action === Action.BLOCK) {
     *     // block the domain
     * }
     * ```
     *
     * For more information on how to use the package, please refer to the NPM package description.
     *
     * ### Priority lists
     * The API aggregates different proprietary Blowfish lists and ecosystem lists. In some cases, different lists may have conflicting data on whether to block or allow a domain. By providing `priorityBlockLists` and `priorityAllowLists`, you can override the results in these cases.
     *
     * If a domain is blocked by one of the lists that Blowfish aggregates, but included in one of `priorityAllowLists`, it will not be included in the blocklist snapshot. Conversely, if a domain is allow-listed by one of the lists that Blowfish aggregates, but is included in one of `priorityBlockLists`, it will be included in the snapshot.
     *
     * This is an advanced feature for integrators who want granular control over blocking domains. By default, the API uses internal list priority heuristics designed for most use cases. The Blowfish team continuously monitors the quality of the underlying blocklists and removes incorrect entries.
     *
     * Blowfish can also ingest custom blocklists and allowlists. If you have a custom list, you can reach out to the Blowfish team and provide a publicly available URL with the domains in a .txt format.
     */
    post: operations["download-blocklist"];
  };
  "/v0/domains": {
    /**
     * Domain
     * @description This endpoint allows customers to analyze dApp domains to determine if they are safe for users to interact with
     */
    post: operations["scan-domain"];
  };
  "/v0/report": {
    /**
     * Report
     * @description This endpoint allows to send additional data about user's behaviour after viewing a scanning result from Blowfish. For each scan, you can send events like `PROCEEDED` (when user decided to sign the transaction), `REJECTED` (when user decided to abort the transaction flow) and `REPORTED_MALICIOUS` (when user explicitly marked the submitted transaction as malicious).
     *
     * We review and analyze reports to improve the accuracy of our security engine.
     */
    post: operations["Report"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Unauthorized: {
      /**
       * @description The error that caused the 401
       * @example Unauthorized: invalid X-API-KEY header value
       */
      error: string;
    };
    BadRequest: {
      /**
       * @description The error that caused the 400
       * @example No transactions to simulate
       */
      error: string;
    };
    InternalServerError: {
      /**
       * @example Internal Server Error
       * @enum {string}
       */
      error: "Internal Server Error";
    };
    /**
     * @description An enum value specifying the suggested action for a wallet to take.
     * Possible values:
     *   - `BLOCK`: Show the user a block screen instead of the signing UI since this is highly likely to be a malicious transaction. We suggest still having a greyed out link allowing the user to proceed if they really think they know better
     *   - `WARN`: Show the user the supplied warnings.
     *   - `NONE`: Show the signing UI without modification.
     *
     * @example WARN
     * @enum {string}
     */
    ActionEnum: "NONE" | "BLOCK" | "WARN";
    /** @description An array of warnings generated from scanning the transactions. All these warnings won't be returned in a single response (some are mutually exclusive) but it is advisable that your UI can display multiple warnings. Warnings are returned sorted by severity, so if you can only show a user one warning, show them the one at the 0th index. */
    Warning: {
      /**
       * @description warning severity level. We suggest a yellow message if "WARNING", and a red message if "CRITICAL".
       * @example WARNING
       * @enum {string}
       */
      severity: "CRITICAL" | "WARNING";
      /**
       * @description Warning kind. Can be used to override specific warnings with your own custom versions. We reserve the right to add new warnings as the need arises, so your UI should likewise defer to the supplied message if the kind isn't recognized by your code.
       * @example SUSPECTED_MALICIOUS
       * @enum {string}
       */
      kind:
        | "APPROVAL_TO_EOA"
        | "BLOCKLISTED_DOMAIN_CROSS_ORIGIN"
        | "BLUR_BULK_ORDER_NOT_ON_BLUR"
        | "BLUR_V2_ORDER_NOT_ON_BLUR"
        | "BULK_APPROVALS_REQUEST"
        | "COMPROMISED_AUTHORITY_UPGRADE"
        | "COPY_CAT_DOMAIN"
        | "COPY_CAT_IMAGE_UNRESPONSIVE_DOMAIN"
        | "DANGLING_APPROVAL"
        | "DEBUGGER_PAUSED"
        | "DURABLE_NONCE"
        | "ETH_SIGN_TX_HASH"
        | "FORTA"
        | "IMBALANCED_DOLLAR_VALUE"
        | "KNOWN_MALICIOUS"
        | "MALICIOUS_PACKAGES"
        | "MULTI_COPY_CAT_DOMAIN"
        | "NEW_DOMAIN"
        | "PERMIT_NO_EXPIRATION"
        | "PERMIT_UNLIMITED_ALLOWANCE"
        | "POISONED_ADDRESS"
        | "REFERENCED_OFAC_ADDRESS"
        | "SEMI_TRUSTED_BLOCKLIST_DOMAIN"
        | "SET_OWNER_AUTHORITY"
        | "SUSPECTED_MALICIOUS"
        | "TOO_MANY_TRANSACTIONS"
        | "TRADE_FOR_NOTHING"
        | "TRADE_FOR_UNVERIFIED_NFT"
        | "TRANSFERRING_ERC20_TO_OWN_CONTRACT"
        | "TRANSFERRING_TOO_MUCH_SOL"
        | "TRANSFERS_MAJORITY_OF_YOUR_SOL"
        | "TRUSTED_BLOCKLIST_DOMAIN"
        | "UNLIMITED_ALLOWANCE_TO_NFTS"
        | "UNUSUAL_GAS_CONSUMPTION"
        | "USER_ACCOUNT_OWNER_CHANGE"
        | "WHITELISTED_DOMAIN_CROSS_ORIGIN"
        | "YAKOA_NFT_IP_INFRINGEMENT";
      /**
       * @description human-readable message to present to the end-user
       * @example Domain found on blocklists maintained by: Blowfish. This website is very likely to be a scam.
       */
      message: string;
    }[];
    /**
     * @description Expected response content type
     * @default application/json
     * @example application/json
     */
    ContentType: string;
    /**
     * @description API version like 2023-06-05
     * @default 2023-06-05
     * @example 2023-06-05
     */
    ApiVersionHeader: string;
    /**
     * @description Specify the desired language for the returned warning messages and human-readable simulation results. If unknown, defaults to English.
     * @default en
     * @example en
     * @enum {string}
     */
    Languages:
      | "am"
      | "ar"
      | "ar-SA"
      | "ar-EG"
      | "ar-DZ"
      | "ar-MA"
      | "ar-IQ"
      | "ar-JO"
      | "ar-KW"
      | "ar-LB"
      | "ar-LY"
      | "ar-OM"
      | "ar-QA"
      | "ar-SY"
      | "ar-TN"
      | "ar-AE"
      | "ar-YE"
      | "bn"
      | "fr"
      | "fr-BE"
      | "fr-CA"
      | "fr-FR"
      | "fr-LU"
      | "fr-CH"
      | "de"
      | "de-AT"
      | "de-DE"
      | "de-LI"
      | "de-LU"
      | "de-CH"
      | "en"
      | "en-US"
      | "en-GB"
      | "en-CA"
      | "en-AU"
      | "en-NZ"
      | "en-ZA"
      | "en-IE"
      | "en-IN"
      | "en-SG"
      | "en-JM"
      | "en-BZ"
      | "en-TT"
      | "en-PH"
      | "it"
      | "it-IT"
      | "it-CH"
      | "ms"
      | "ms-BN"
      | "ms-MY"
      | "pt"
      | "pt-BR"
      | "pt-PT"
      | "ru"
      | "ru-RU"
      | "es"
      | "es-AR"
      | "es-BO"
      | "es-CL"
      | "es-CO"
      | "es-CR"
      | "es-CU"
      | "es-DO"
      | "es-EC"
      | "es-SV"
      | "es-GQ"
      | "es-GT"
      | "es-HN"
      | "es-MX"
      | "es-NI"
      | "es-PA"
      | "es-PY"
      | "es-PE"
      | "es-PH"
      | "es-PR"
      | "es-ES"
      | "es-US"
      | "es-UY"
      | "es-VE"
      | "sw"
      | "tr"
      | "tr-TR"
      | "fil"
      | "gu_IN"
      | "ha"
      | "hi"
      | "id"
      | "ig"
      | "ja"
      | "ko"
      | "my"
      | "pa"
      | "ta"
      | "th"
      | "vi"
      | "yo"
      | "zh_CN"
      | "zh_TW";
    RequestMetadata: {
      /**
       * @description DApp domain proposing these transactions
       * @example https://uniswap.org
       */
      origin: string;
    };
    AssetPrice: {
      /**
       * @example Coingecko
       * @enum {string}
       */
      source: "Simplehash" | "Defillama" | "Coingecko";
      /** @example 1679331222 */
      updatedAt: number;
      /**
       * Format: float
       * @example 0.2784
       */
      dollarValuePerToken: number;
    } | null;
    /** @description Decoded events emmited by this transaction */
    EvmDecodedLogs: components["schemas"]["EvmDecodedLog"][];
    /** @description Decoded event. Null if not decoded */
    EvmDecodedLog: {
      /**
       * @description Event name
       * @example Approval
       */
      name: string;
      /**
       * @description Hash of event signature. First topic
       * @example 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
       */
      signature: string;
      params: components["schemas"]["EvmDecodedLogParam"][];
    } | null;
    EvmDecodedLogParam: {
      /** @description Parameter name */
      name: string;
      /** @description Parameter type */
      paramType: string;
      value: components["schemas"]["EvmAbiSerializedToken"];
    };
    /**
     * @description Parsed `data` field of the transaction using the contract's ABI. We don't recommend displaying this field to users when contract isn't trusted
     * (for example, using `protocol` field), as scammers can verify ABI with arbitrary and misleading function names (e.g. `withdraw`, when it's actually a transfer).
     * Can be `null` if ABI is not available for contract or we failed to parse it.
     */
    EvmDecodedCalldata:
      | components["schemas"]["EvmDecodedCalldataFunction"]
      | components["schemas"]["EvmDecodedCalldataProxiedFunction"]
      | null;
    /** @description Direct function call in a contract. */
    EvmDecodedCalldataFunction: {
      /**
       * @example FUNCTION
       * @enum {string}
       */
      kind: "FUNCTION";
      data: {
        /**
         * @description Contract address from `to` field that was called
         * @example 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48
         */
        contract: string;
        /**
         * @description Name of the called function in the contract
         * @example transfer
         */
        functionName: string;
        arguments: components["schemas"]["EvmDecodedCalldataArgument"][];
      };
    };
    /**
     * @description Function call in a contract that went through a fallback on a proxy contract.
     * We include function name and arguments for the final implementation contract.
     */
    EvmDecodedCalldataProxiedFunction: {
      /**
       * @example PROXIED_FUNCTION
       * @enum {string}
       */
      kind: "PROXIED_FUNCTION";
      data: {
        /**
         * @description Original proxy contract address from `to` field
         * @example 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48
         */
        contract: string;
        /**
         * @description Implementation contract address that was called after going through the proxy and contains the parsed function
         * @example 0xa2327a938febf5fec13bacfb16ae10ecbc4cbdcf
         */
        proxiedImplementation: string;
        /**
         * @description Name of the called function in the contract
         * @example transfer
         */
        functionName: string;
        arguments: components["schemas"]["EvmDecodedCalldataArgument"][];
      };
    };
    /** @description Argument of a function call. */
    EvmDecodedCalldataArgument: {
      /**
       * @description Name of the argument
       * @example to
       */
      name: string;
      value: components["schemas"]["EvmAbiSerializedToken"];
      /**
       * @description Type of the argument
       * @example address
       */
      paramType: string;
    };
    /**
     * @description Solidity token value. Addresses are serialized with `0x` prefix. Bytes and numbers are serialized as hex with `0x` prefix.
     * Serialized as a list of tokens if parameter is an array.
     */
    EvmAbiSerializedToken: (string | string[])[] | string;
    /** @description Events emmited by this transaction */
    EvmLogs: components["schemas"]["EvmLog"][];
    EvmLog: {
      /** @example 0xa725f1a12b69eb32a7aea885c826deffaad6e3f3 */
      address: string;
      topics: string[];
      /** @example 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925 */
      data: string;
    };
    /** @description An object that contains nullable fields with information about the estimated gas consumption of the simulated transaction */
    EvmGas: {
      /**
       * @description A field that if the simulation was successful contains the estimated upper limit of gas usage for this transaction. The gasLimit should be viewed as an upper bound of how much gas the transaction can use, not as an accurate estimate how much it will realistically consume when submitted on-chain. Can be `null`.
       * @example 46220
       */
      gasLimit: string | null;
    };
    EvmSimulationResults: {
      aggregated: components["schemas"]["EvmAggregatedSimulationResults"];
      perTransaction: components["schemas"]["EvmPerTransactionSimulationResults"];
    };
    EvmAggregatedSimulationResults: {
      userAccount: components["schemas"]["EvmUserAccount"];
      expectedStateChanges: components["schemas"]["EvmByAccountExpectedStateChanges"];
      error: components["schemas"]["EvmAggregatedSimulationError"];
    };
    EvmPerTransactionSimulationResults: {
      error: components["schemas"]["EvmPerTransactionError"];
      gas: components["schemas"]["EvmGas"];
      protocol: components["schemas"]["EvmProtocol"];
      logs: components["schemas"]["EvmLogs"];
      decodedLogs: components["schemas"]["EvmDecodedLogs"];
      decodedCalldata: components["schemas"]["EvmDecodedCalldata"];
    }[];
    /** @description A error object which includes the parsed simulation error encountered (if any). Can be `null`. */
    EvmAggregatedSimulationError:
      | components["schemas"]["EvmSimulationFailedError"]
      | components["schemas"]["EvmUnknownError"]
      | null;
    /** @description A error object which includes the parsed simulation error encountered (if any). Can be `null`. */
    EvmPerTransactionError:
      | components["schemas"]["EvmTransactionRevertedError"]
      | components["schemas"]["EvmTransactionError"]
      | components["schemas"]["EvmSimulationFailedError"]
      | components["schemas"]["EvmUnknownError"]
      | null;
    EvmSimulationResult: {
      expectedStateChanges: components["schemas"]["EvmExpectedStateChanges"];
      error: components["schemas"]["EvmPerTransactionError"];
      gas: components["schemas"]["EvmGas"];
      protocol: components["schemas"]["EvmProtocol"];
    };
    /** @description Human-readable protocol information. Note that a single protocol can consist of multiple contracts. */
    EvmProtocol: {
      /**
       * @description `NATIVE` means it’s a native asset transfer, an operation on WETH or any other transaction that is considered to be as secure as the chain itself. `TRUSTED` means it’s one of core projects that control 80-90% of TVL on the chain. `KNOWN` means it’s one of “long tail projects” without significant adoption.
       *
       * @example KNOWN
       * @enum {string}
       */
      trustLevel: "KNOWN" | "TRUSTED" | "NATIVE";
      /** @example Uniswap */
      name: string;
      /** @example A decentralized token exchange */
      description: string;
      /**
       * @description URL of the protocol's logo. Can be null if no logo is available.
       * @example https://d2xobe0ejktb0m.cloudfront.net/attEQcQmNq7dbhjwB.png
       */
      imageUrl: string | null;
      /** @example https://uniswap.org */
      websiteUrl: string;
    } | null;
    /** @description Human-readable protocol information. Note that a single protocol can consist of multiple programs. */
    SolanaProtocol: {
      /**
       * @description `NATIVE` means it’s a SOL transfer, an SPL Program or any other program written and maintained by the Solana Foundation. `TRUSTED` means it’s one of the core projects that control 80-90% of TVL on the chain. `KNOWN` means it’s one of “long tail projects” without significant adoption."
       *
       * @example KNOWN
       * @enum {string}
       */
      trustLevel: "KNOWN" | "TRUSTED" | "NATIVE";
      /** @example Memo Program */
      name: string;
      /** @example A protocol to publish on-chain text messages */
      description: string;
      /**
       * @description URL of the protocol's logo. Can be null if no logo is available.
       * @example https://d2xobe0ejktb0m.cloudfront.net/attEQcQmNq7dbhjwB.png
       */
      imageUrl: string | null;
      /** @example https://solana.com */
      websiteUrl: string;
    };
    /** @description Information about each instruction */
    SolanaInstruction: {
      /**
       * @description Index of the protocol in the list of protocols for this instruction
       * @example 0
       */
      protocolIndex: number | null;
    };
    /**
     * @example fungible
     * @enum {string}
     */
    MetaplexTokenStandard:
      | "non_fungible"
      | "fungible_asset"
      | "fungible"
      | "non_fungible_edition"
      | "unknown";
    EvmTxHash: string;
    EvmTxData: {
      /**
       * @description Hex-representation address of transaction signer
       * @example 0xa725f1a12b69eb32a7aea885c826deffaad6e3f3
       */
      from?: string;
      /**
       * @description Hex-representation address of transaction recipient
       * @example 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
       */
      to?: string;
      /**
       * @description Hex-representation of ABI encoded call data
       * @example 0x095ea7b30000000000000000000000001d5071048370df50839c8879cdf5144ace4b3b3bffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
       */
      data?: string;
      /**
       * @description String representation of Ether/Matic (in Wei) to send with the transaction
       * @example 0
       */
      value?: string;
    };
    EvmExpectedStateChange: {
      /**
       * @description Computed explanation of the state change that can be directly presented to the end-user. While the API is still in development, we suggest integrators expose this in their signing UI if they encounter a `rawInfo.kind` they don't recognize.
       * @example Send 10000 USDT
       */
      humanReadableDiff: string;
      /** @description A machine-parsable state change object describing the state change. */
      rawInfo:
        | components["schemas"]["EvmStateChangeErc20Transfer"]
        | components["schemas"]["EvmStateChangeErc20Approval"]
        | components["schemas"]["EvmStateChangeNativeAssetTransfer"]
        | components["schemas"]["EvmStateChangeErc721Transfer"]
        | components["schemas"]["EvmStateChangeErc721Approval"]
        | components["schemas"]["EvmStateChangeErc721ApprovalForAll"]
        | components["schemas"]["EvmStateChangeErc721LockApproval"]
        | components["schemas"]["EvmStateChangeErc721LockApprovalForAll"]
        | components["schemas"]["EvmStateChangeErc721Lock"]
        | components["schemas"]["EvmStateChangeErc1155Transfer"]
        | components["schemas"]["EvmStateChangeErc1155ApprovalForAll"];
    };
    EvmExpectedStateChanges: components["schemas"]["EvmExpectedStateChange"][];
    /** @description A mapping of account to the state changes to expect if these transactions were submitted on-chain. Each state change represents a meaningful change to the account's assets or permissions on-chain. We reserve the right to add new state change types, so any handling logic custom to state change types should fallback gracefully to showing the end-user the `humanReadableDiff` of any unrecognized state change types. */
    EvmByAccountExpectedStateChanges: {
      [key: string]: components["schemas"]["EvmExpectedStateChanges"];
    };
    /**
     * @description A hex-representation of the user account who is being asked to sign the supplied transaction. In most cases this will be the same as the from property in the txObject
     * @example 0xc1e42f862d202b4a0ed552c1145735ee088f6ccf
     */
    EvmUserAccount: string;
    /** @description An optional advanced usage configuration to change the simulator environment during simulation. Under normal circumstances this configuration should not be set when making requests. */
    EvmSimulatorConfig: {
      /** @description Simulate the transaction at the head of this historical block. Note that transaction enrichment data may not contain historical values and execution may differ from on-chain execution due to block transaction index variations affecting the outcome */
      blockNumber?: string;
      stateOverrides?: {
        nativeBalances: {
          /**
           * @description The account for which to override the native balance during simulation
           * @example 0xdac17f958d2ee523a2206206994597c13d831ec7
           */
          address: string;
          /** @description The amount in native token base units to set the account balance to. This value can be passed in either decimal or 0x prefixed hexadecimal form */
          value: string;
        }[];
        storage: {
          /**
           * @description The address of the contract for which to override storage in the simulation
           * @example 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
           */
          address: string;
          /** @description The storage slot in the contract's storage to override. This value can be passed in either decimal or 0x prefixed hexadecimal form */
          slot: string;
          /** @description The numerical value to set the storage slot to. This value can be passed in either decimal or 0x prefixed hexadecimal form */
          value: string;
        }[];
      };
    };
    EvmAddressInfo: {
      /**
       * @description The blockchain address
       * @example 0xdac17f958d2ee523a2206206994597c13d831ec7
       */
      address: string;
      /**
       * @description The type of address
       * @example ACCOUNT
       * @enum {string}
       */
      kind: "ACCOUNT";
    };
    /** @example USDT */
    EvmSymbol: string;
    /** @example Tether USD */
    EvmName: string;
    /** @example Bored Ape Yacht Club */
    EvmCollectionName: string;
    /** @description Metadata associated with the NFT */
    EvmNftMetadata: {
      /**
       * Format: uri
       * @example https://cdn.simplehash.com/assets/6c5f6c40f8de4c54c8af25c5dd7b352dd7f8f6cf0acfa548494da24c9b194f44.png
       */
      rawImageUrl: string;
    };
    /**
     * @description The ID of the ERC721 token. Can be `null` in some edge cases where we are temporarily unable to parse it.
     * @example 100
     */
    EvmErc721TokenId: string | null;
    /**
     * @description The ID of the ERC1155 token. Can be `null`.
     * @example 100
     */
    EvmErc1155TokenId: string | null;
    EvmAmount: {
      /**
       * @description The value of the amount after the state change occurs
       * @example 5000000000
       */
      after: string;
      /**
       * @description The value of the amount before the state change occurs
       * @example 15000000000
       */
      before: string;
    };
    EvmErc1155Asset: {
      address: components["schemas"]["EvmContractAddress"];
      name: components["schemas"]["EvmName"];
      /** @description A $-value price of the asset. Floor price of the collection if asset is an NFT. Can be `null`. */
      price: components["schemas"]["AssetPrice"];
    };
    EvmErc721Asset: {
      address: components["schemas"]["EvmContractAddress"];
      /** @description Some NFTs don't have a symbol as it's not required in a standard */
      symbol: components["schemas"]["EvmSymbol"];
      /** @description Some NFTs don't have a name as it's not required in a standard */
      name: components["schemas"]["EvmName"];
      /** @description Some NFTs don't have a collection name as it's not required in a standard */
      collection: components["schemas"]["EvmCollectionName"];
      /** @description A $-value price of the asset. Floor price of the collection if asset is an NFT. Can be `null`. */
      price: components["schemas"]["AssetPrice"];
    };
    EvmErc20Asset: {
      address: components["schemas"]["EvmContractAddress"];
      /**
       * @description The symbol of the asset
       * @example USDT
       */
      symbol: string;
      /**
       * @description The name of the asset
       * @example Tether USD
       */
      name: string;
      /**
       * @description The number of decimal places used by the asset
       * @example 6
       */
      decimals: number;
      /**
       * @description Whether the asset is verified as safe
       * @example true
       */
      verified: boolean;
      /** @description The trusted token lists on which this asset is listed */
      lists: (
        | "COINGECKO"
        | "ZERION"
        | "ONE_INCH"
        | "UNISWAP"
        | "MY_CRYPTO_API"
        | "KLEROS_TOKENS"
        | "POLYGON_POPULAR_TOKENS"
        | "EVM_NATIVE"
        | "BLOWFISH"
      )[];
      /**
       * @description The URL of the asset's image. Can be `null`.
       * @example https://d1ts37qlq4uz4s.cloudfront.net/evm__evm%3A%3Aethereum__evm%3A%3Aethereum%3A%3Amainnet__0x6b175474e89094c44da98b954eedeac495271d0f.png
       */
      imageUrl: string | null;
      /** @description A $-value price of the asset. Floor price of the collection if asset is an NFT. Can be `null`. */
      price: components["schemas"]["AssetPrice"];
    };
    EvmAsset: {
      /**
       * @description The contract address of the asset
       * @example 0xdac17f958d2ee523a2206206994597c13d831ec7
       */
      address: string;
      /**
       * @description The symbol of the asset
       * @example USDT
       */
      symbol: string;
      /**
       * @description The name of the asset
       * @example Tether USD
       */
      name: string;
      /**
       * @description The number of decimal places used by the asset
       * @example 6
       */
      decimals: number;
      /**
       * @description Whether the asset is verified as safe
       * @example true
       */
      verified: boolean;
      /** @description The trusted token lists on which this asset is listed */
      lists: (
        | "COINGECKO"
        | "ZERION"
        | "ONE_INCH"
        | "UNISWAP"
        | "MY_CRYPTO_API"
        | "KLEROS_TOKENS"
        | "POLYGON_POPULAR_TOKENS"
        | "EVM_NATIVE"
        | "BLOWFISH"
      )[];
      /**
       * @description The URL of the asset's image. Can be `null`.
       * @example https://d1ts37qlq4uz4s.cloudfront.net/evm__evm%3A%3Aethereum__evm%3A%3Aethereum%3A%3Amainnet__0x6b175474e89094c44da98b954eedeac495271d0f.png
       */
      imageUrl: string | null;
      /** @description A $-value price of the asset. Floor price of the collection if asset is an NFT. Can be `null`. */
      price: components["schemas"]["AssetPrice"];
    };
    EvmNativeAsset: {
      address: components["schemas"]["EvmContractAddress"];
      /**
       * @description The symbol of the asset
       * @example USDT
       */
      symbol: string;
      /**
       * @description The name of the asset
       * @example Tether USD
       */
      name: string;
      /**
       * @description The number of decimal places used by the asset. Always true for the native asset.
       * @example 6
       */
      decimals: number;
      /**
       * @description Whether the asset is verified as safe
       * @example true
       * @enum {boolean}
       */
      verified: true;
      /**
       * @description The URL of the asset's image. Can be `null`.
       * @example https://d1ts37qlq4uz4s.cloudfront.net/evm__evm%3A%3Aethereum__evm%3A%3Aethereum%3A%3Amainnet__0x6b175474e89094c44da98b954eedeac495271d0f.png
       */
      imageUrl: string | null;
      /** @description A $-value price of the asset. Floor price of the collection if asset is an NFT. Can be `null`. */
      price: components["schemas"]["AssetPrice"];
    };
    /**
     * @description The contract address of the asset
     * @example 0xdac17f958d2ee523a2206206994597c13d831ec7
     */
    EvmContractAddress: string;
    EvmSignTypedData: {
      /**
       * @example SIGN_TYPED_DATA
       * @enum {string}
       */
      kind?: "SIGN_TYPED_DATA";
      data?: {
        types?: {
          EIP712Domain?: {
            /** @example Seaport */
            name?: string;
            /** @example string */
            type?: string;
          }[];
          [key: string]: unknown;
        };
        /** @example OrderComponents */
        primaryType?: string;
        domain?: {
          /** @example Seaport */
          name?: string;
          /** @example 1.4 */
          version?: string;
          /** @example 1 */
          chainId?: string;
          /** @example 0x00000000000001ad428e4906aE43D8F9852d0dD6 */
          verifyingContract?: string;
        };
        message?: {
          [key: string]: unknown;
        };
      };
    };
    EvmSignMessage: {
      /**
       * @example SIGN_MESSAGE
       * @enum {string}
       */
      kind: "SIGN_MESSAGE";
      /**
       * @description The hex encoded eth_sign message that the dapp is proposing the user to sign.
       * @example 0x40ac14ef28d35fb4540e0cd0950123b378224d3585ec887c26f7a510da544552
       */
      rawMessage: string;
    };
    EvmTransactionRevertedError: {
      /**
       * @example TRANSACTION_REVERTED
       * @enum {string}
       */
      kind: "TRANSACTION_REVERTED";
      /**
       * @description Human readable explanation of the error
       * @example Transaction reverted (Token does not exist)
       */
      humanReadableError: string;
      /**
       * @description Why the transaction reverted
       * @example execution reverted: Too little received
       */
      revertReason: string;
    };
    EvmTransactionError: {
      /**
       * @example TRANSACTION_ERROR
       * @enum {string}
       */
      kind: "TRANSACTION_ERROR";
      /**
       * @description Human readable explanation of the error
       * @example Transaction error (LackOfFundForGasLimit)
       */
      humanReadableError: string;
      /**
       * @description For all the errors during the execution that do not have a revert reason. Like InvalidOpcode or LackOfFundForGasLimit.
       * @example LackOfFundForGasLimit
       */
      errorType: string;
    };
    EvmSimulationFailedError: {
      /**
       * @example SIMULATION_FAILED
       * @enum {string}
       */
      kind: "SIMULATION_FAILED";
      /**
       * @description Human readable explanation of the error
       * @example Transaction simulation failed
       */
      humanReadableError: string;
      /**
       * @description Internal reason for the simulation failure
       * @example Example reason
       */
      reason: string;
    };
    EvmUnknownError: {
      /**
       * @example UNKNOWN_ERROR
       * @enum {string}
       */
      kind: "UNKNOWN_ERROR";
      /**
       * @description Human readable explanation of the error
       * @example Unable to simulate transaction
       */
      humanReadableError: string;
    };
    /** @description Contains counterparty adress if known. To whom the transfer was made for Send or from whom was it made for Receive */
    EvmTransferCounterparty: components["schemas"]["EvmAddressInfo"];
    /** @description ERC20 token transfers */
    EvmStateChangeErc20Transfer: {
      /**
       * @description What kind of state change this object is
       * @example ERC20_TRANSFER
       * @enum {string}
       */
      kind: "ERC20_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        amount: components["schemas"]["EvmAmount"];
        counterparty?: components["schemas"]["EvmTransferCounterparty"];
        asset: components["schemas"]["EvmErc20Asset"];
      };
    };
    /** @description Approval request to transfer user's ERC20 tokens */
    EvmStateChangeErc20Approval: {
      /**
       * @description What kind of state change this object is
       * @example ERC20_APPROVAL
       * @enum {string}
       */
      kind: "ERC20_APPROVAL";
      /** @description Data associated with the state change */
      data: {
        /** @description The owner of the ERC20 tokens */
        owner: components["schemas"]["EvmAddressInfo"];
        /** @description The entity that will be allowed to spend them if the approval is granted */
        spender: components["schemas"]["EvmAddressInfo"];
        amount: components["schemas"]["EvmAmount"];
        asset: components["schemas"]["EvmErc20Asset"];
      };
    };
    /** @description ETH transfers */
    EvmStateChangeNativeAssetTransfer: {
      /**
       * @description What kind of state change this object is
       * @example NATIVE_ASSET_TRANSFER
       * @enum {string}
       */
      kind: "NATIVE_ASSET_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        amount: components["schemas"]["EvmAmount"];
        counterparty: components["schemas"]["EvmTransferCounterparty"];
        asset: components["schemas"]["EvmNativeAsset"];
      };
    };
    /** @description ERC721 NFT transfers */
    EvmStateChangeErc721Transfer: {
      /**
       * @description What kind of state change this object is
       * @example ERC721_TRANSFER
       * @enum {string}
       */
      kind: "ERC721_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        amount: components["schemas"]["EvmAmount"];
        counterparty: components["schemas"]["EvmTransferCounterparty"];
        metadata: components["schemas"]["EvmNftMetadata"];
        tokenId: components["schemas"]["EvmErc721TokenId"];
        asset: components["schemas"]["EvmErc721Asset"];
      };
    };
    /** @description Data associated with the state change */
    EvmStateChangeErc721ApprovalData: {
      amount: components["schemas"]["EvmAmount"];
      metadata: components["schemas"]["EvmNftMetadata"];
      owner: components["schemas"]["EvmAddressInfo"];
      spender: components["schemas"]["EvmAddressInfo"];
      tokenId: components["schemas"]["EvmErc721TokenId"];
      asset: components["schemas"]["EvmErc721Asset"];
    };
    /** @description Lock approval request for a specific token in an ERC721 collection */
    EvmStateChangeErc721LockApproval: {
      /**
       * @description What kind of state change this object is
       * @example ERC721_LOCK_APPROVAL
       * @enum {string}
       */
      kind: "ERC721_LOCK_APPROVAL";
      data: components["schemas"]["EvmStateChangeErc721ApprovalData"];
    };
    /** @description Approval request for a specific token in an ERC721 collection */
    EvmStateChangeErc721Approval: {
      /**
       * @description What kind of state change this object is
       * @example ERC721_APPROVAL
       * @enum {string}
       */
      kind: "ERC721_APPROVAL";
      data: components["schemas"]["EvmStateChangeErc721ApprovalData"];
    };
    /** @description Data associated with the state change */
    EvmStateChangeErc721LockData: {
      amount: components["schemas"]["EvmAmount"];
      metadata: components["schemas"]["EvmNftMetadata"];
      owner: components["schemas"]["EvmAddressInfo"];
      tokenId: components["schemas"]["EvmErc721TokenId"];
      asset: components["schemas"]["EvmErc721Asset"];
    };
    /** @description Lock/unlock request for a specific token in an ERC721 collection */
    EvmStateChangeErc721Lock: {
      /**
       * @description What kind of state change this object is
       * @example ERC721_LOCK
       * @enum {string}
       */
      kind: "ERC721_LOCK";
      data: components["schemas"]["EvmStateChangeErc721LockData"];
    };
    /** @description Data associated with the state change */
    EvmStateChangeErc721ApprovalForAllData: {
      amount: components["schemas"]["EvmAmount"];
      owner: components["schemas"]["EvmAddressInfo"];
      spender: components["schemas"]["EvmAddressInfo"];
      asset: components["schemas"]["EvmErc721Asset"];
    };
    /** @description Lock approval request for all owned ERC721 NFTs in a collection */
    EvmStateChangeErc721LockApprovalForAll: {
      /**
       * @description What kind of state change this object is
       * @example ERC721_LOCK_APPROVAL_FOR_ALL
       * @enum {string}
       */
      kind: "ERC721_LOCK_APPROVAL_FOR_ALL";
      data: components["schemas"]["EvmStateChangeErc721ApprovalForAllData"];
    };
    /** @description Approval request for all owned ERC721 NFTs in a collection */
    EvmStateChangeErc721ApprovalForAll: {
      /**
       * @description What kind of state change this object is
       * @example ERC721_APPROVAL_FOR_ALL
       * @enum {string}
       */
      kind: "ERC721_APPROVAL_FOR_ALL";
      data: components["schemas"]["EvmStateChangeErc721ApprovalForAllData"];
    };
    /** @description ERC1155 transfers */
    EvmStateChangeErc1155Transfer: {
      /**
       * @description What kind of state change this object is
       * @example ERC1155_TRANSFER
       * @enum {string}
       */
      kind: "ERC1155_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        amount: components["schemas"]["EvmAmount"];
        metadata: components["schemas"]["EvmNftMetadata"];
        tokenId: components["schemas"]["EvmErc1155TokenId"];
        counterparty?: components["schemas"]["EvmTransferCounterparty"];
        asset: components["schemas"]["EvmErc1155Asset"];
      };
    };
    /** @description Approval request for all owned ERC1155 assets */
    EvmStateChangeErc1155ApprovalForAll: {
      /**
       * @description What kind of state change this object is
       * @example ERC1155_APPROVAL_FOR_ALL
       * @enum {string}
       */
      kind: "ERC1155_APPROVAL_FOR_ALL";
      /** @description Data associated with the state change */
      data: {
        amount: components["schemas"]["EvmAmount"];
        /** @description The owner of the ERC1155 tokens */
        owner: components["schemas"]["EvmAddressInfo"];
        /** @description The entity that will be allowed to transfer all the owner's tokens of the given ERC1155 contract if the approval is granted */
        spender: components["schemas"]["EvmAddressInfo"];
        asset: components["schemas"]["EvmErc1155Asset"];
      };
    };
    /** @description ERC20 token permit message */
    EvmMessageStateChangeErc20Permit: {
      /**
       * @description What kind of state change this object is
       * @example ERC20_PERMIT
       * @enum {string}
       */
      kind: "ERC20_PERMIT";
      /** @description Data associated with the state change */
      data: {
        contract: components["schemas"]["EvmAddressInfo"];
        /** @description The owner of the ERC20 tokens */
        owner: components["schemas"]["EvmAddressInfo"];
        /** @description The entity that will be allowed to spend them if the permit is granted */
        spender: components["schemas"]["EvmAddressInfo"];
        /**
         * @description Stringified base unit amount of the token
         * @example 115792089237316195423570985008687907853269984665640564039457584007913129639935
         */
        amount: string;
        /**
         * @description Stringified nonce number
         * @example 0
         */
        nonce: string;
        /**
         * @description Unix timestamp when this permit will expire. Can be `null`: indicates no deadline.
         * @example 1667556263
         */
        deadline: number | null;
        asset: components["schemas"]["EvmAsset"];
      };
    };
    /** @description ERC20 token transfers */
    EvmMessageStateChangeErc20Transfer: {
      /**
       * @description What kind of state change this object is
       * @example ERC20_TRANSFER
       * @enum {string}
       */
      kind: "ERC20_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        contract: components["schemas"]["EvmAddressInfo"];
        amount: components["schemas"]["EvmAmount"];
        asset: components["schemas"]["EvmAsset"];
      };
    };
    /** @description ETH transfers */
    EvmMessageStateChangeNativeAssetTransfer: {
      /**
       * @description What kind of state change this object is
       * @example NATIVE_ASSET_TRANSFER
       * @enum {string}
       */
      kind: "NATIVE_ASSET_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        contract: components["schemas"]["EvmAddressInfo"];
        amount: components["schemas"]["EvmAmount"];
        asset: components["schemas"]["EvmNativeAsset"];
      };
    };
    /** @description ERC721 NFT transfers */
    EvmMessageStateChangeErc721Transfer: {
      /**
       * @description What kind of state change this object is
       * @example ERC721_TRANSFER
       * @enum {string}
       */
      kind: "ERC721_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        amount: components["schemas"]["EvmAmount"];
        counterparty?: components["schemas"]["EvmTransferCounterparty"];
        contract: components["schemas"]["EvmAddressInfo"];
        metadata: components["schemas"]["EvmNftMetadata"];
        name: components["schemas"]["EvmName"];
        symbol: components["schemas"]["EvmSymbol"];
        tokenId: components["schemas"]["EvmErc721TokenId"];
        /** @description The NFT collection's $-value floor price */
        assetPrice: components["schemas"]["AssetPrice"];
      };
    };
    /** @description ERC1155 transfers */
    EvmMessageStateChangeErc1155Transfer: {
      /**
       * @description What kind of state change this object is
       * @example ERC1155_TRANSFER
       * @enum {string}
       */
      kind: "ERC1155_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        name: components["schemas"]["EvmName"];
        amount: components["schemas"]["EvmAmount"];
        contract: components["schemas"]["EvmAddressInfo"];
        metadata: components["schemas"]["EvmNftMetadata"];
        tokenId: components["schemas"]["EvmErc1155TokenId"];
        /** @description The NFT collection's $-value floor price */
        assetPrice: components["schemas"]["AssetPrice"];
      };
    };
    /** @description A "wildcard" NFT transfer representing the transfer of any NFT from a given collection (eg. Opensea collection offers) */
    EvmMessageStateChangeAnyNftFromCollectionTransfer: {
      /**
       * @description What kind of state change this object is
       * @example ANY_NFT_FROM_COLLECTION_TRANSFER
       * @enum {string}
       */
      kind: "ANY_NFT_FROM_COLLECTION_TRANSFER";
      /** @description Data associated with the state change */
      data: {
        amount: components["schemas"]["EvmAmount"];
        /** @description Represents NFT collection as a whole, including collection-level image, etc. */
        asset: {
          address: components["schemas"]["EvmContractAddress"];
          /** @description Some NFTs don't have a symbol/name as it's not required in a standard */
          symbol: components["schemas"]["EvmSymbol"];
          /** @description Some NFTs don't have a symbol/name as it's not required in a standard */
          name: components["schemas"]["EvmName"];
          /** @description A $-value price of the asset. Floor price of the collection if asset is an NFT. Can be `null`. */
          price?: components["schemas"]["AssetPrice"];
          /**
           * @description The URL of the collection's cover image
           * @example https://lh3.googleusercontent.com/C_fjl1iM5iRwuk74N9DBrOmU-1-_lc_8x66BsWU8votTb3iwXiVJwmqJ2qd8BUI1DSDo_9KxcNcNJrdpnnxebLwpeJB7eiYSeI8
           */
          imageUrl?: string | null;
          /**
           * @description The type of specified NFT
           * @example ERC721
           * @enum {string}
           */
          type: "ERC721" | "ERC1155";
        };
      };
    };
    /** @description Solana native token transfer */
    SolanaStateChangeSolTransfer: {
      /**
       * @description What kind of state change this object is
       * @example SOL_TRANSFER
       * @enum {string}
       */
      kind: "SOL_TRANSFER";
      /** @description Machine-parseable data relevant to this state change kind */
      data: {
        asset: components["schemas"]["SolAsset"];
        diff: components["schemas"]["Diff"];
      };
    };
    Diff: {
      /**
       * @description Whether the amount is positive or negative
       * @example PLUS
       * @enum {string}
       */
      sign: "PLUS" | "MINUS";
      /** @example 500000 */
      digits: number;
    };
    SolAsset: {
      /**
       * @description Symbol of the Solana native token
       * @example SOL
       */
      symbol: string;
      /**
       * @description Name of the Solana native token
       * @example Solana Native Token
       */
      name: string;
      /**
       * @description Decimals of the Solana native token
       * @example 9
       */
      decimals: number;
      /** @description The $-value price of the asset */
      price: components["schemas"]["AssetPrice"];
      /**
       * @description Image URL for the Solana native token
       * @example https://d1ts37qlq4uz4s.cloudfront.net/solana__solana%3A%3Asolana__solana%3A%3Asolana%3A%3Amainnet__So11111111111111111111111111111111111111112.png
       */
      imageUrl: string;
    };
    SplAsset: {
      /**
       * @description SPL token symbol
       * @example USDC
       */
      symbol: string;
      /**
       * @description SPL token name
       * @example USD Coin
       */
      name: string;
      /**
       * @description The SPL token mint program address
       * @example EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
       */
      mint: string;
      /**
       * @description SPL token decimals
       * @example 13
       */
      decimals: number;
      /**
       * @description SPL token supply
       * @example 1
       */
      supply: number;
      /** @description The Metaplex token standard for this asset if any */
      metaplexTokenStandard: components["schemas"]["MetaplexTokenStandard"];
      /** @description The $-value price of the asset */
      price: components["schemas"]["AssetPrice"];
      /**
       * @description The URL of the asset's image. Can be `null`.
       * @example https://cdn.simplehash.com/assets/2b6b37a30a85f4d7f3727574afc296026d3453cc813f982a7c4c358668060ea9.png
       */
      imageUrl: string | null;
    };
    /** @description SPL token transfer */
    SolanaStageChangeSplTransfer: {
      /**
       * @description What kind of state change this object is
       * @example SPL_TRANSFER
       * @enum {string}
       */
      kind: "SPL_TRANSFER";
      data: {
        asset: components["schemas"]["SplAsset"];
        diff: components["schemas"]["Diff"];
      };
    };
    /** @description Approval request to transfer user's tokens */
    SolanaStateChangeSplApproval: {
      /**
       * @description What kind of state change this object is
       * @example SPL_APPROVAL
       * @enum {string}
       */
      kind: "SPL_APPROVAL";
      data: {
        /**
         * @description Who will be able to transfer the user's tokens on their behalf
         * @example 3kQJyZKC4tdQy3nqCqFiLDT2V7dzG65vSKtkUGCht5L3
         */
        delegate: string;
        asset: components["schemas"]["SplAsset"];
        diff: components["schemas"]["Diff"];
      };
    };
    /** @description Transferring control over a user's Solana account to a different program (defaults to Solana system program) */
    SolanaStateChangeUserAccountOwnerChange: {
      /**
       * @description What kind of state change this object is
       * @example USER_ACCOUNT_OWNER_CHANGE
       * @enum {string}
       */
      kind: "USER_ACCOUNT_OWNER_CHANGE";
      data: {
        /**
         * @description The Solana account whose ownership would be changed
         * @example 2AG3beWwvyvEMLfwJcQS9DKMV62C3UWTTf8d7gp2vFQS
         */
        account: string;
        /**
         * @description Amount of lamports in this account
         * @example 123354533212
         */
        lamports: number;
        /**
         * @description Current program that is the owner for this account
         * @example 11111111111111111111111111111111
         */
        currentOwner: string;
        /**
         * @description Future program that will be the new owner for this account
         * @example EpochxXNkmM2akxBTuCEizW1oWyzgrPZ1CVZ3GpD7Egm
         */
        futureOwner: string;
      };
    };
    /** @description Transferring control over a user's SOL staking account */
    SolanaStateChangeSolStakeAuthorityChange: {
      /**
       * @description What kind of state change this object is
       * @example SOL_STAKE_AUTHORITY_CHANGE
       * @enum {string}
       */
      kind: "SOL_STAKE_AUTHORITY_CHANGE";
      data: {
        /**
         * @description The stake account address
         * @example 2AG3beWwvyvEMLfwJcQS9DKMV62C3UWTTf8d7gp2vFQS
         */
        stakeAccount: string;
        /** @description Current authorities with control over the staking account */
        currentAuthorities: {
          /**
           * @description Authority who can make staking changes
           * @example J58MrVr9qJPzJJS8RPQUDfaFirN3PiVHXU48zr95FY48
           */
          staker: string;
          /**
           * @description Authority who can withdraw the funds from the staking account
           * @example J58MrVr9qJPzJJS8RPQUDfaFirN3PiVHXU48zr95FY48
           */
          withdrawer: string;
        };
        /** @description Future authorities who will have control over the staking account */
        futureAuthorities: {
          /**
           * @description Authority who can make staking changes
           * @example EpochxXNkmM2akxBTuCEizW1oWyzgrPZ1CVZ3GpD7Egm
           */
          staker: string;
          /**
           * @description Authority who can withdraw the funds from the staking account
           * @example EpochxXNkmM2akxBTuCEizW1oWyzgrPZ1CVZ3GpD7Egm
           */
          withdrawer: string;
        };
        asset: components["schemas"]["SolAsset"];
        /**
         * @description Amount of SOL staked by this account
         * @example 1000000000000
         */
        solStaked: number;
      };
    };
    /** @description A error object which includes the parsed simulation error encountered (if any). Can be `null`. */
    SolanaSimulationError:
      | components["schemas"]["SolanaSimulationTransactionError"]
      | components["schemas"]["SolanaSimulationProgramError"]
      | null;
    SolanaSimulationProgramError: {
      /**
       * @example PROGRAM_ERROR
       * @enum {string}
       */
      kind: "PROGRAM_ERROR";
      /**
       * @description Human-readable version of the error.
       * @example Lamport balance below rent-exempt threshold
       */
      humanReadableError: string;
      /**
       * @description The address of the Solana program where this revert error occurred
       * @example ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
       */
      solanaProgramAddress: string;
    };
    SolanaSimulationTransactionError: {
      /**
       * @example TRANSACTION_ERROR
       * @enum {string}
       */
      kind?: "TRANSACTION_ERROR";
      /**
       * @description Human-readable version of the error. Values match the string version of the `TransactionError` enum values in the Solana repo
       * @example Blockhash not found
       */
      humanReadableError: string;
    };
    /** @description An error object describing why we were unable to simulate the transactions in the request. Can be `null`. */
    BlowfishSimulationError: {
      /**
       * @description The error that caused us to be unable to run transaction simulation for this request. `SIMULATION_TIMED_OUT` is returned if the simulation took too long and timed out. `BAD_REQUEST` is returned if the transaction(s) or `user_account` submitted were invalid (this is similar to a 400 bad request). `TOO_MANY_TRANSACTIONS` is returned if a request includes too many transactions (current max: 100 txns). `SIMULATION_FAILED` is returned if simulation failed because of a dependent RPC failure or internal server error during simulation execution.
       * @example BAD_REQUEST
       * @enum {string}
       */
      kind:
        | "SIMULATION_FAILED"
        | "SIMULATION_TIMED_OUT"
        | "TOO_MANY_TRANSACTIONS"
        | "BAD_REQUEST";
      /**
       * @description Human readable version of the error with more details about why it failed (esp. for BAD_REQUEST). SIMULATION_FAILED is only returned if we were unable to run the simulation because of an internal error (akin to a 500 error code).
       * @example User account supplied in request not found
       */
      humanReadableError: string;
    } | null;
    /** @description Raw results of the simulation */
    SolanaRawSimulationResults: {
      /**
       * @description Program instruction error causing the failure. Can be `null`.
       * @example BlockhashNotFound
       */
      err: string | null;
      /** @description Program logs generated during execution */
      logs: string[];
      /**
       * Format: int32
       * @example 148013
       */
      unitsConsumed: number;
      /** @description Can be `null`. */
      returnData: {
        /**
         * @description the program that generated the return data, as base-58 encoded Pubkey
         * @example TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
         */
        programId: string;
        /**
         * @description The return data itself, as base-64 encoded binary data and it's encoding as the second element
         * @example [
         *   "AQAAANVgbnOWDT3H5I2/oye32/palPUEeT1S5fbKj2WqgpTuAQAAAAAAAAAAAQEAAADVYG5zlg09x+SNv6Mnt9v6WpT1BHk9UuX2yo9lqoKU7g==",
         *   "base64"
         * ]
         */
        data: string[];
      } | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /**
   * EVM
   * @description Simulates historical transaction to get the actual state changes it produced.
   * ### Supported networks
   * | Network | Base URL |
   * | --- | --- |
   * | Ethereum Mainnet | https://api.blowfish.xyz/ethereum/v0/mainnet/historical/transaction |
   * | Goerli Testnet | https://api.blowfish.xyz/ethereum/v0/goerli/historical/transaction |
   * | Polygon Mainnet | https://api.blowfish.xyz/polygon/v0/mainnet/historical/transaction |
   * | Polygon Mumbai Testnet  | https://api.blowfish.xyz/polygon/v0/mumbai/historical/transaction |
   * | BNB Chain Mainnet | https://api.blowfish.xyz/bnb/v0/mainnet/historical/transaction |
   * | Arbitrum One | https://api.blowfish.xyz/arbitrum/v0/one/historical/transaction |
   * | Optimism Goerli Testnet | https://api.blowfish.xyz/optimism/v0/goerli/historical/transaction |
   * | Optimism Mainnet | https://api.blowfish.xyz/optimism/v0/mainnet/historical/transaction |
   * | Base Mainnet | https://api.blowfish.xyz/base/v0/mainnet/historical/transaction |
   * | Base Goerli Testnet | https://api.blowfish.xyz/base/v0/goerli/historical/transaction |
   */
  "historical-transaction-evm": {
    parameters: {
      query?: {
        /** @description The language to use in the returned human-readable warnings and simulation results */
        language?: components["schemas"]["Languages"];
      };
      header: {
        /** @description Which version of the API to use */
        "X-Api-Version": components["schemas"]["ApiVersionHeader"];
        /** @description The expected return content type */
        "Content-Type"?: components["schemas"]["ContentType"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          txHash: components["schemas"]["EvmTxHash"];
          userAccount: components["schemas"]["EvmUserAccount"];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": components["schemas"]["EvmSimulationResults"];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequest"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["Unauthorized"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["InternalServerError"];
        };
      };
    };
  };
  /**
   * EVM
   * @description Scan a list of EVM transactions in order to receive recommended actions, tailored warnings and human-readable simulation results explaining what the transactions will do.
   * ### Supported networks
   * | Network | Base URL |
   * | --- | --- |
   * | Ethereum Mainnet | https://api.blowfish.xyz/ethereum/v0/mainnet/scan/transactions |
   * | Goerli Testnet | https://api.blowfish.xyz/ethereum/v0/goerli/scan/transactions |
   * | Polygon Mainnet | https://api.blowfish.xyz/polygon/v0/mainnet/scan/transactions |
   * | Polygon Mumbai Testnet  | https://api.blowfish.xyz/polygon/v0/mumbai/scan/transactions |
   * | BNB Chain Mainnet | https://api.blowfish.xyz/bnb/v0/mainnet/scan/transactions |
   * | Arbitrum One | https://api.blowfish.xyz/arbitrum/v0/one/scan/transactions |
   * | Optimism Goerli Testnet | https://api.blowfish.xyz/optimism/v0/goerli/scan/transactions |
   * | Base Mainnet | https://api.blowfish.xyz/base/v0/mainnet/scan/transactions |
   * | Base Goerli Testnet | https://api.blowfish.xyz/base/v0/goerli/scan/transactions |
   * Note:  All EVM scan endpoints are equivalent when it comes to functionality as well as request and response formats.
   */
  "scan-transactions-evm": {
    parameters: {
      query?: {
        /** @description The language to use in the returned human-readable warnings and simulation results */
        language?: components["schemas"]["Languages"];
      };
      header: {
        /** @description Which version of the API to use */
        "X-Api-Version": components["schemas"]["ApiVersionHeader"];
        /** @description The expected return content type */
        "Content-Type"?: components["schemas"]["ContentType"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          txObjects: components["schemas"]["EvmTxData"][];
          metadata: components["schemas"]["RequestMetadata"];
          userAccount: components["schemas"]["EvmUserAccount"];
          simulatorConfig?: components["schemas"]["EvmSimulatorConfig"];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            action: components["schemas"]["ActionEnum"];
            warnings: components["schemas"]["Warning"];
            simulationResults: components["schemas"]["EvmSimulationResults"];
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequest"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["Unauthorized"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["InternalServerError"];
        };
      };
    };
  };
  /**
   * EVM
   * @deprecated
   * @description [DEPRECATED] Use Scan transactions endpoint instead.
   * https://docs.blowfish.xyz/reference/scan-transactions-evm
   * [Sunset] 31.12.2023
   * Scan an EVM transaction in order to receive recommended actions, tailored warnings and human-readable simulation results explaining what the transaction will do.
   * ### Supported networks
   * | Network | Base URL |
   * | --- | --- |
   * | Ethereum Mainnet | https://api.blowfish.xyz/ethereum/v0/mainnet/scan/transaction |
   * | Goerli Testnet | https://api.blowfish.xyz/ethereum/v0/goerli/scan/transaction |
   * | Polygon Mainnet | https://api.blowfish.xyz/polygon/v0/mainnet/scan/transaction |
   * | Polygon Mumbai Testnet  | https://api.blowfish.xyz/polygon/v0/mumbai/scan/transaction |
   * | BNB Chain Mainnet | https://api.blowfish.xyz/bnb/v0/mainnet/scan/transaction |
   * | Arbitrum One | https://api.blowfish.xyz/arbitrum/v0/one/scan/transaction |
   * | Optimism Goerli Testnet | https://api.blowfish.xyz/optimism/v0/goerli/scan/transaction |
   * | Optimism Mainnet | https://api.blowfish.xyz/optimism/v0/mainnet/scan/transaction |
   * | Base Mainnet | https://api.blowfish.xyz/base/v0/mainnet/scan/transaction |
   * | Base Goerli Testnet | https://api.blowfish.xyz/base/v0/goerli/scan/transaction |
   * Note:  All EVM scan endpoints are equivalent when it comes to functionality as well as request and response formats.
   */
  "scan-transaction-evm": {
    parameters: {
      query?: {
        /** @description The language to use in the returned human-readable warnings and simulation results */
        language?: components["schemas"]["Languages"];
      };
      header: {
        /** @description Which version of the API to use */
        "X-Api-Version": components["schemas"]["ApiVersionHeader"];
        /** @description The expected return content type */
        "Content-Type"?: components["schemas"]["ContentType"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          txObject: components["schemas"]["EvmTxData"];
          metadata: components["schemas"]["RequestMetadata"];
          userAccount: components["schemas"]["EvmUserAccount"];
          simulatorConfig?: components["schemas"]["EvmSimulatorConfig"];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            action: components["schemas"]["ActionEnum"];
            warnings: components["schemas"]["Warning"];
            simulationResults: components["schemas"]["EvmSimulationResult"];
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequest"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["Unauthorized"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["InternalServerError"];
        };
      };
    };
  };
  /**
   * EVM
   * @description Scan an EVM message in order to receive recommended actions, tailored warnings and human-readable simulation results explaining what signing the message will do.
   * ### Supported networks
   * | Network | Base URL |
   * | --- | --- |
   * | Ethereum Mainnet | https://api.blowfish.xyz/ethereum/v0/mainnet/scan/message |
   * | Goerli Testnet | https://api.blowfish.xyz/ethereum/v0/goerli/scan/message |
   * | Polygon Mainnet | https://api.blowfish.xyz/polygon/v0/mainnet/scan/message |
   * | Polygon Mumbai Testnet  | https://api.blowfish.xyz/polygon/v0/mumbai/scan/message |
   * | BNB Chain Mainnet | https://api.blowfish.xyz/bnb/v0/mainnet/scan/message |
   * | Arbitrum One | https://api.blowfish.xyz/arbitrum/v0/one/scan/message |
   * | Optimism Goerli Testnet | https://api.blowfish.xyz/optimism/v0/goerli/scan/message |
   * | Optimism Mainnet | https://api.blowfish.xyz/optimism/v0/mainnet/scan/message |
   * | Base Mainnet | https://api.blowfish.xyz/base/v0/mainnet/scan/message |
   * | Base Goerli Testnet | https://api.blowfish.xyz/base/v0/goerli/scan/message |
   * Note:  All EVM scan endpoints are equivalent when it comes to functionality as well as request and response formats.
   */
  "scan-message-evm": {
    parameters: {
      query?: {
        /** @description The language to use in the returned human-readable warnings and simulation results */
        language?: components["schemas"]["Languages"];
      };
      header: {
        /** @description Which version of the API to use */
        "X-Api-Version": components["schemas"]["ApiVersionHeader"];
        /** @description The expected return content type */
        "Content-Type"?: components["schemas"]["ContentType"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description An object containing the message type and contents */
          message:
            | components["schemas"]["EvmSignTypedData"]
            | components["schemas"]["EvmSignMessage"];
          metadata: components["schemas"]["RequestMetadata"];
          userAccount: components["schemas"]["EvmUserAccount"];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            action: components["schemas"]["ActionEnum"];
            warnings: components["schemas"]["Warning"];
            /**
             * @description Can be `null`. Message simulation requires in-depth understanding of the contract verifying the message and is not a generalizable solution that works for any message. If we do not support simulating a particular message the simulationResults property will be returned as null and the recommended action is to fallback to showing the raw message data to the user before they sign
             * Currently supported messages: OpenSea Seaport orders & ERC20 Permit approvals
             */
            simulationResults: {
              expectedStateChanges: {
                /**
                 * @description Computed explanation of the state change that can be directly presented to the end-user. While the API is still in development, we suggest integrators expose this in their signing UI if they encounter a `rawInfo.kind` they don't recognize.
                 * @example Send 10000 USDT
                 */
                humanReadableDiff: string;
                /** @description A machine-parsable state change object describing the state change. */
                rawInfo:
                  | components["schemas"]["EvmMessageStateChangeErc20Permit"]
                  | components["schemas"]["EvmMessageStateChangeErc20Transfer"]
                  | components["schemas"]["EvmMessageStateChangeNativeAssetTransfer"]
                  | components["schemas"]["EvmMessageStateChangeErc721Transfer"]
                  | components["schemas"]["EvmMessageStateChangeErc1155Transfer"]
                  | components["schemas"]["EvmMessageStateChangeAnyNftFromCollectionTransfer"];
              }[];
              /** @description A nullable error object which includes the parsed simulation error encountered (if any) */
              error: {
                /**
                 * @description A unique representation of the error kind
                 *
                 * UNSUPPORTED_ORDER_TYPE: Opensea order simulation currently supports basic order types for swapping ERC20/721/1155 <-> ERC20/721/1155, advanced order types using attribute criteria are not supported. If the message is a valid OpenSea order but of a type not supported UNSUPPORTED_ORDER_TYPE will be returned
                 *
                 * UNKNOWN_ERROR: We were not able to simulate the state changes of the message for an unknown reason, however the transaction it self did not revert so the user can proceed with caution
                 *
                 * UNSUPPORTED_MESSAGE: We do not support decoding this message type.
                 *
                 * @example UNSUPPORTED_ORDER_TYPE
                 * @enum {string}
                 */
                kind:
                  | "UNSUPPORTED_ORDER_TYPE"
                  | "UNKNOWN_ERROR"
                  | "UNSUPPORTED_MESSAGE";
                /**
                 * @description Human readable & translated string that can be directly exposed to end-users
                 * @example Unsupported order type, unable to simulate message
                 */
                humanReadableError: string;
              } | null;
              protocol: components["schemas"]["EvmProtocol"];
            } | null;
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequest"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["Unauthorized"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["InternalServerError"];
        };
      };
    };
  };
  /**
   * Solana
   * @description Scan Solana transactions in order to receive recommended actions, tailored warnings and human-readable simulation results explaining what the transaction will do. The API will return a list of warnings and a list of human-readable simulation results.
   * ### Supported networks
   * | Network | Base URL |
   * | --- | --- |
   * | Mainnet | https://api.blowfish.xyz/solana/v0/mainnet/scan/transactions |
   * | Testnet | https://api.blowfish.xyz/solana/v0/testnet/scan/transactions |
   * | Devnet | https://api.blowfish.xyz/solana/v0/devnet/scan/transactions |
   */
  "scan-transactions-solana": {
    parameters: {
      query?: {
        /** @description The language to use in the returned human-readable warnings and simulation results */
        language?: components["schemas"]["Languages"];
        /** @description The desired timeout for the transaction simulation (defaults to 30 seconds) */
        simulationTimeoutMs?: number;
        /** @description Simulate the transactions even if they are already expired. Do not use in production. This can be helpful in understanding historical transactions. */
        simulateExpired?: "true" | "false";
      };
      header: {
        /** @description Which version of the API to use */
        "X-Api-Version": components["schemas"]["ApiVersionHeader"];
        /** @description The expected return content type */
        "Content-Type"?: components["schemas"]["ContentType"];
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Base58 or Base64 encoded Solana transactions to scan */
          transactions: string[];
          /**
           * @description Base58-encoded account of signer of transactions
           * @example 5ufzDEwP2jKrvx78inuWNPrXRmR9AcXySqc2B3CRqR3G
           */
          userAccount: string;
          metadata: components["schemas"]["RequestMetadata"];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            aggregated: {
              action: components["schemas"]["ActionEnum"];
              warnings: components["schemas"]["Warning"];
              error: components["schemas"]["BlowfishSimulationError"];
              /** @description A mapping of account to the state changes to expect if these transactions were submitted on-chain. Each state change represents a meaningful change to the account's assets or permissions on-chain. We reserve the right to add new state change types, so any handling logic custom to state change types should fallback gracefully to showing the end-user the `humanReadableDiff` of any unrecognized state change types. */
              expectedStateChanges: {
                [key: string]: {
                  /**
                   * @description Computed explanation of the state change that can be directly presented to the end-user. While the API is still in development, we suggest integrators expose this in their signing UI since the list of state change kinds has not yet stabilized.
                   * @example Receive 0.05657 SOL
                   */
                  humanReadableDiff: string;
                  /**
                   * @description Suggested text color when presenting the diff to end-users
                   * @example CREDIT
                   * @enum {string}
                   */
                  suggestedColor: "CREDIT" | "DEBIT";
                  /** @description A machine-parsable state change object describing the state change. */
                  rawInfo:
                    | components["schemas"]["SolanaStateChangeSolTransfer"]
                    | components["schemas"]["SolanaStageChangeSplTransfer"]
                    | components["schemas"]["SolanaStateChangeSplApproval"]
                    | components["schemas"]["SolanaStateChangeSolStakeAuthorityChange"]
                    | components["schemas"]["SolanaStateChangeUserAccountOwnerChange"];
                }[];
              };
            };
            perTransaction: {
              /**
               * @description Whether the tx nonce is valid
               * @example false
               */
              isNonceValid: boolean;
              error: components["schemas"]["SolanaSimulationError"];
              raw: components["schemas"]["SolanaRawSimulationResults"];
              protocols: components["schemas"]["SolanaProtocol"][];
              instructions: components["schemas"]["SolanaInstruction"][];
            }[];
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequest"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["Unauthorized"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["InternalServerError"];
        };
      };
    };
  };
  /**
   * Blocklist
   * @description Generate a downloadable snapshot with all blocked domains in order to check domains a user visits against a local blocklist, preserving their browsing privacy.
   *
   * ### Integration
   * This API enables to verify domain safety while maintaining the end user's privacy. To integrate this API into your app, you should follow the steps below:
   *
   * 1. Regularly update the blocklist metadata from the `/v0/domains/blocklist` endpoint.
   *   - In browser extensions, set up a timer to update the blocklist every 2-5 minutes.
   *   - In mobile apps, update the blocklist each time the user opens the app and every 2-5 minutes while the user is using the app.
   *   - New values of `recentlyAdded` and `recentlyRemoved` should be stored after each update, regardless of whether the bloom filter has changed.
   * 2. During each update, check if the app has previously downloaded a bloom filter with the hash `bloomFilter.hash`. If not, download it from `bloomFilter.url`.
   *   - Since the bloom filter can be up to 1MB in size, make sure you never re-download the same bloom filter. Identical bloom filters always have the same URL and the same hash.
   *   - Store the blocklist metadata (`recentlyAdded`, `recentlyRemoved`), bloom filter hash, and downloaded bloom filter.
   *   - Chrome extensions can use localStorage. The endpoint is designed with a 5MB limit on localStorage in mind.
   *   - The bloom filter is changed once a day, so users will never use more than 1 MB of traffic per day if the download and local caching logic is implemented correctly.
   * 3. When the user visits a domain, check if the domain is present on the bloom filter or the `recentlyAdded` list from the blocklist metadata and isn't present on the `recentlyRemoved` list. If this is the case, block the user from visiting the website.
   *
   * Browser extensions and React Native apps can use the Javascript package [@blowfish/blocklist](https://www.npmjs.com/package/@blowfishxyz/blocklist) to implement the outlined logic. For example:
   *
   * ```js
   * // Regular updates
   * import { fetchDomainBlocklist, fetchDomainBlocklistBloomFilter } from '@blowfishxyz/blocklist';
   *
   * const blocklist = await fetchDomainBlocklist(apiConfig);
   * [...] // save blocklist.recentlyAdded and blocklist.recentlyRemoved to a local database
   * const storedHash = [...]; // fetch it from your storage
   * if (storedHash != blocklist.bloomFilter.hash) {
   *     const bloomFilter = await fetchDomainBlocklistBloomFilter(blocklist.bloomFilter.url);
   *     [...] // save bloomFilter to a local database
   *     [...] // save bloomFilter.hash or blocklist.bloomFilter.hash to a local database
   * }
   *
   * // Lookups
   * import { scanDomain, Action } from '@blowfishxyz/blocklist';
   *
   * const recentlyAdded = [...]; // get from storage
   * const recentlyRemoved = [...]; // get from storage
   * const bloomFilter = [...]; // get from storage
   *
   * const action = scanDomain(
   *     bloomFilter,
   *     recentlyAdded,
   *     recentlyRemoved,
   *     "https://example.com/"
   * );
   *
   * if (action === Action.BLOCK) {
   *     // block the domain
   * }
   * ```
   *
   * For more information on how to use the package, please refer to the NPM package description.
   *
   * ### Priority lists
   * The API aggregates different proprietary Blowfish lists and ecosystem lists. In some cases, different lists may have conflicting data on whether to block or allow a domain. By providing `priorityBlockLists` and `priorityAllowLists`, you can override the results in these cases.
   *
   * If a domain is blocked by one of the lists that Blowfish aggregates, but included in one of `priorityAllowLists`, it will not be included in the blocklist snapshot. Conversely, if a domain is allow-listed by one of the lists that Blowfish aggregates, but is included in one of `priorityBlockLists`, it will be included in the snapshot.
   *
   * This is an advanced feature for integrators who want granular control over blocking domains. By default, the API uses internal list priority heuristics designed for most use cases. The Blowfish team continuously monitors the quality of the underlying blocklists and removes incorrect entries.
   *
   * Blowfish can also ingest custom blocklists and allowlists. If you have a custom list, you can reach out to the Blowfish team and provide a publicly available URL with the domains in a .txt format.
   */
  "download-blocklist": {
    parameters: {
      header: {
        /** @description Which version of the API to use */
        "X-Api-Version": components["schemas"]["ApiVersionHeader"];
        /** @description The expected return content type */
        "Content-Type"?: components["schemas"]["ContentType"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Excludes domain from the blocklist if it is present on one of these lists */
          allowLists?: ("BLOWFISH" | "METAMASK" | "DEFILLAMA")[];
          /** @description Block domain if it is present on one of these lists */
          blockLists?: (
            | "PHANTOM"
            | "BLOWFISH"
            | "BLOWFISH_AUTOMATED"
            | "SOLFARE"
            | "PHISHFORT"
            | "SCAMSNIFFER"
            | "METAMASK"
          )[];
          /** @description Override domain blocking if domain is present on one of these lists, even if it's block-listed on of regular block lists */
          priorityAllowLists?: ("BLOWFISH" | "METAMASK" | "DEFILLAMA")[];
          /** @description Always block domain if it present on one of these lists, even if it's allow-listed on one of regular allow lists */
          priorityBlockLists?: (
            | "PHANTOM"
            | "BLOWFISH"
            | "BLOWFISH_AUTOMATED"
            | "SOLFARE"
            | "PHISHFORT"
            | "SCAMSNIFFER"
            | "METAMASK"
          )[];
          /**
           * @description How long a bloom filter and corresponding `hash` should remain static. By default, 24 hours. Minimum 24 hours, maximum 14 days. During this time, new domains will be added to `recentlyAdded` and removed from `recentlyRemoved` fields.
           * @example 86400
           */
          bloomFilterTtl?: number;
        };
      };
    };
    responses: {
      /**
       * @description A successful API response will include a link to download the bloom filter, which contains all blocked domains and any domains that were recently added to or removed from the filter.
       *
       * It's important to note that the recentlyAdded and recentlyRemoved fields take precedence over the bloom filter result.
       * The bloom filter is updated every 24 hours by default (can be customized with `bloomFilterTtl` parameter. If new domains are added or removed, they will be listed in the recentlyAdded and recentlyRemoved fields until the bloom filter is updated.
       * The bloom filter file, located at bloomFilter.url, is guaranteed to be less than 1 MB
       */
      200: {
        content: {
          "application/json": {
            bloomFilter: {
              /**
               * Format: uri
               * @example https://d1ts37qlq4uz4s.cloudfront.net/e9087494a6b9fa71c26788a7111b1c9384ad9f539139d0b33c9856c3fc0351b2.json
               */
              url: string;
              /** @example e9087494a6b9fa71c26788a7111b1c9384ad9f539139d0b33c9856c3fc0351b2 */
              hash: string;
            };
            recentlyAdded: string[];
            recentlyRemoved: string[];
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequest"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["Unauthorized"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["InternalServerError"];
        };
      };
    };
  };
  /**
   * Domain
   * @description This endpoint allows customers to analyze dApp domains to determine if they are safe for users to interact with
   */
  "scan-domain": {
    parameters: {
      header: {
        /** @description Which version of the API to use */
        "X-Api-Version": components["schemas"]["ApiVersionHeader"];
        /** @description The expected return content type */
        "Content-Type"?: components["schemas"]["ContentType"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          domains?: string[];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            /**
             * @description A sanitized, registerable representation of the URL submitted. By registerable, we mean either the domain registerable with a domain registrar (e.g., example.com) or a sub-domain registerable on a hosting providers domain (e.g., my-project.vercel.app).
             * @example dustprotocol.dev
             */
            domain: string;
            /**
             * @description The status of our domain analysis. Since our analysis can take some time, rather than block the API request until we've finished, we schedule the evaluation and return a response immediately.
             *
             * PROCESSING -> The analysis is under way
             * UNPROCESSABLE -> We were unable to analyze the domain. This usually means that the website was unreachable or did not include valid HTML
             * PROCESSED -> Our analysis completed successfully
             *
             * @example PROCESSED
             * @enum {string}
             */
            status: "PROCESSED" | "PROCESSING" | "UNPROCESSABLE";
            /**
             * Format: float
             * @description A risk score from 0.0 to 1.0. The higher the score, the higher our certainty that this domain is hosting a crypto-native scam.
             * @example 1
             */
            riskScore: number | null;
            /**
             * @description Additional metadata about the domain and our evaluation. Possible labels include
             *
             * Blockchain -> Which blockchain this domain attempts to interact with
             * Warning -> If we've detected scam-like behavior, a warning label describing what was found will be included. If we know which blockchain the scam dApp is built for, this information is also included. We reserve the right to add new warnings at any time so handle new additions gracefully.
             * Copy-cat -> If this dApp is a copy-cat of a well-known brand, we include a copy-cat label with information of the brand it is impersonating and it's official domain
             */
            labels: (
              | "blockchain=solana"
              | "blockchain=ethereum"
              | "blockchain=polygon"
              | "warning[all]=BLOCKLISTED_DOMAIN_CROSS_ORIGIN"
              | "warning[all]=OBFUSCATED_CODE"
              | "warning[all]=DEVTOOLS_DISABLED"
              | "warning[all]=WHITELISTED_DOMAIN_CROSS_ORIGIN"
              | "warning[all]=TRUSTED_BLOCKLIST_DOMAIN"
              | "warning[all]=NON_ASCII_URL"
              | "warning[evm]=BLOCKLISTED_DOMAIN_CROSS_ORIGIN"
              | "warning[evm]=OBFUSCATED_CODE"
              | "warning[evm]=DEVTOOLS_DISABLED"
              | "warning[evm]=WHITELISTED_DOMAIN_CROSS_ORIGIN"
              | "warning[evm]=TRUSTED_BLOCKLIST_DOMAIN"
              | "warning[solana]=NON_ASCII_URL"
              | "warning[solana]=BLOCKLISTED_DOMAIN_CROSS_ORIGIN"
              | "warning[solana]=OBFUSCATED_CODE"
              | "warning[solana]=DEVTOOLS_DISABLED"
              | "warning[solana]=WHITELISTED_DOMAIN_CROSS_ORIGIN"
              | "warning[solana]=TRUSTED_BLOCKLIST_DOMAIN"
              | "source=blowfish_blocklist"
              | "source=blowfish_whitelist"
              | "source=metamask_blocklist"
              | "source=metamask_whitelist"
              | "source=phishfort_blocklist"
              | "source=scamsniffer_blocklist"
              | "source=phantom_blocklist"
              | "source=solflare_blocklist"
              | "source=defi_llama_whitelist"
              | "source=brand_whitelist"
              | "copy_cat=brand_name:domain"
            )[];
            warnings: components["schemas"]["Warning"];
          }[];
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequest"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["Unauthorized"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["InternalServerError"];
        };
      };
    };
  };
  /**
   * Report
   * @description This endpoint allows to send additional data about user's behaviour after viewing a scanning result from Blowfish. For each scan, you can send events like `PROCEEDED` (when user decided to sign the transaction), `REJECTED` (when user decided to abort the transaction flow) and `REPORTED_MALICIOUS` (when user explicitly marked the submitted transaction as malicious).
   *
   * We review and analyze reports to improve the accuracy of our security engine.
   */
  Report: {
    parameters: {
      header: {
        /** @description Which version of the API to use */
        "X-Api-Version": components["schemas"]["ApiVersionHeader"];
        /** @description The expected return content type */
        "Content-Type"?: components["schemas"]["ContentType"];
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Request ID of transaction/message scan to report. This can be found in both the headers
           * and the returned objects of our requests as `X-Request-Id`.
           *
           * @example eafdae18039f531b5a586310cfbd654e
           */
          requestId?: string;
          /**
           * @description What event occurred to cause the report. "PROCEEDED" means the user proceeded with signing
           * the proposed action, "REJECTED" means the user rejected the proposed action, and "Reported
           * Malicious" means the user explicitly reported the transaction as malicious.
           *
           * @enum {string}
           */
          event?: "PROCEEDED" | "REJECTED" | "REPORTED_MALICIOUS";
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          "application/json": {
            /**
             * @description The Request ID of the successfully reported transaction/message scan.
             * @example eafdae18039f531b5a586310cfbd654e
             */
            requestId?: string;
          };
        };
      };
      /** @description Bad request */
      400: {
        content: {
          "application/json": components["schemas"]["BadRequest"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["Unauthorized"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["InternalServerError"];
        };
      };
    };
  };
}
